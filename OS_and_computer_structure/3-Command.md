## 3-1 소스코드와 명령어

### 고급 언어와 저급 언어
우리가 프로그램을 만들 때  사용하는 프로그래밍 언어는 컴퓨터가 이해하는 언어가 아닌 사람이 이해하기 위해 만들어진 언어다. 이런 사람을 위해 만들어진 언어를 `고급 언어`라고 한다.  
반대로 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 `저급 언어`라고 한다.   
`고급 언어`로 작성된 소스 코드가 실행되려면 반드시 `저급 언어`, 즉 `명령어`로 변환되어야 한다.  

`저급 언어`에는 두 가지 종류가 있다. 바로 `기계어`와 `어셈블리어`이다.  
`기계어`란 0과 1의 명령어 비트로 이루어진 언어이다. 다만, 기계어를 이진수로 나열하면 너무 길어지기 때문에 십육진수로 표현하곤 한다.  
`기계어`는 오직 컴퓨터만을 위해 만들어진 언어이기 때문에 사람이 그 의미를 이해하기 어렵다. 그래서 등장한 언어가 `어셈블리어`이다.  

### 컴파일 언어와 인터프리터 언어
고급 언어가 저급 언어로 변환되는 방식에는 크게 두 가지, `컴파일` 방식과 `인터프리트` 방식이 있다. 컴파일 방식으로 작동하는 언어를 `컴파일 언어`, 인터프리트 방식으로 작동하는 언어를 `인터프리터 언어`라고 한다.

#### 컴파일 언어
`컴파일 언어`는 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어이다.  
소스 코드가 저급 언어로 변환되는 과정을 `캄파일`이라고 한다. 그리고 컴파일을 수행해 주는 도구를 `컴파일러`라고 한다.  
컴파일이 성공적으로 수행되면 저급 언어로 변환되는데 변환된 코드를 `목적 코드`라고 한다.

#### 인터프리터 언어
`인터프리터 언어`는 인터프리터에 의해 소스 코드가 한줄 씩 실행되는 고급 언어이다.  
소스 코드 `전체가 변환`되는 컴파일 언어와 다르게, 인터프리터 언어는 소스 코드를 `한줄씩 차례로 실행`한다. 이렇게 변환화여 실행해 주는 도구를 `인터프리터`라고 한다.

소스 코드에 오류가 하나라도 있으면 컴파일이 불가능했던 컴파일 언어와 다르게, 인터프리터 언어는 한줄 씩 실행하기 때문에 N번 째 줄에 문법 오류가 있더라도 N-1번 째 줄까지는 올바르게 수행된다.  

일반적으로 인터프리터 언어는 컴파일 언어에 비해 느리다.

	컴파일 언어와 인터프리터 언어는 칼로 자르듯 나눌 수 없다. `python` 같은 언어도 컴파일을 하지 않는 것이 아니고, `java`같은 경우도 컴파일과 인터프리트를 동시에 수행한다.

#### 목적 언어 vs 실행 파일
목적 코드로 이루어진 파일을 `목적 파일`이라고 부른다. 목적 파일과 실행 파일은 같은 의미가 아니다. 목적 코드가 실행 파일이 되기 위해서는 `링킹`이라는 작업을 거쳐야 한다.  
`출력하기`등의 목적 코드가 가지고 있는 다른 기능은 어떻게 실행하는 지 모르기 때문에 이런 기능을 연결하는 작업이 `링킹`이다.

## 3-2 명령어의 구조

### 연산 코드와 오퍼랜드
명령어는 `무엇을 대상`으로, `어떤 작동`을 수행하라는 구조로 되어 있다.  
어떤 작동을 하라는 명령어가 수행할 연산을 `연산 코드`라고 한다.  
연산에 사용할 데이터 또는 데이터가 저장된 위치를 `오퍼랜드`라고 한다.  
연산 코드는 `연산자`, 오퍼랜드는 `피연산자`라고도 부른다.  

#### 오퍼랜드
오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.  
그래서 오퍼랜드 필드를 `주소 필드`라고 부르기도 한다.  
오퍼랜드 명령어 안에 하나도 없을 수도 있고, 여러 개가 있을 수도 있다.  
여기서 하나도 없는 명령어를 `0-주소 명령어`, 하나인 명령어를 `1-주소 명령어`, 2개는 `2-주소 명령어`, 3개는 `3-주소 명령어`라고 한다. 

#### 연산 코드
연산 코드 종류는 매우 많지만, 기본적인 연산 코드 유형은 크게 네 가지이다.
1. `데이터 전송`
2. `산술/논리 연산`
3. `제어 흐름 변경`
4. `입출력 제어`

명령어의 종류와 생김새는 `CPU`마다 다르기 때문에 연산 코드의 종류와 생김새 또한 `CPU`마다 다르다. 

##### 데이터 전송
* `MOVE` : 데이터를 옮겨라
* `STORE` : 메모리에 저장하라
* `LOAD` (`FETCh`) : 메모리에서 `CPU`로 데이터를 가져와라
* `PUSH` : 스택에 데이터를 저장하라
* `POP` : 스택의 최상단 데이터를 가져와라

##### 산술/논리 연산
* `ADD` / `SUBTARCT` / `MULTIPLY` / `DIVIDE` : 산술 연산을 수행하라
* `INCREMENT` / `DECREMENT` : 오퍼랜드에 1을 더하거나 빼라
* `AND`, `OR`, `NOT` : 논리 연산을 수행하라
* `COMPARE` : 두 개의 숫자 또는 `TRUE` / `FALSE` 값을 비교하라

##### 제어 흐름 변경
* `JUMP` : 특정 주소로 실행 순서롤 옮겨라
* `CONDITIONAL JUMP` : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
* `HALT` : 프로그램의 실행을 멈춰라
* `CALL` : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
* `RETURN` : `CALL`을 호출할 때 저장했던 주소로 돌아가라

##### 입출력 제어
* `READ`(`INPUT`) : 특정 입출력 장치로부터 데이터를 읽어라
* `WRITE`(`OUTPUT`) : 특정 입출력 장치로 데이터를 써라
* `STRAT IO` : 입출력 장치를 시작하라
* `TEST IO` : 입출력 장치의 상태를 확인하라

### 주소 지정 방식
오퍼랜드에 직접적으로 데이터를 직접 넣지 않는 이유는 `명령어의 길이` 때문이다.  
명령어의 크기는 한정되어 있고, 그 중에 `연산 코드가 차지하고 있는 길이`도 제외해야 하기 때문에 데이터가 표현할 수 있는 크기가 제한되어 있다.

하지만 데이터가 들어가 있는 메모리 주소를 명시한다면 표현할 수 있는 정보의 가지수가 확 커지게 된다.  

연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 `유효 주소`라고 한다.  
오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 `주소 지정 방식`이라고 한다.
현대에는 다양한 주소 지정 방식을 사용하는데 대표적으로 5가지가 있다.

#### 즉시 주소 지정 방식
연산에 사용할 데이터를 오퍼랜드 필드에 `직접 명시`하는 방식이다. 
* 장점 : 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없어 빠르다.
* 단점 : 데이터의 크기가 작아진다.

#### 직접 주소 지정 방식
오퍼랜드 `유효 주소를 직접적으로 명시`하는 방식이다.
* 장점 : 즉시 주소 방식보다는 표현할 수 있는 데이터가 더 크다.
* 단점 : 유효 주소에 제한이 생길 수 있다.

#### 간접 주소 지정 방식
`유효 주소의 주소`를 오퍼랜드 필드에 명시한다.
* 장점 : 직접 주소 지정 방식보다 표현할 수 있는 유효 주소 범위가 더 넓다.
* 단점 : 두 번의 메모리 접근이 필요하기 때문에 느리다.

#### 레지스터 주소 지정 방식
직접 주소 지정 방식과 비슷하게 연산에 사용할 `데이터를 저장한 레지스터를 명시`하는 방식
* 장점 : CPU 외부에 있는 메모리에 접근하는 것보다는 레지스터에 접근하는 것이 빠르기 때문에 `더 빠르게 데이터에 접근`할 수 있다.
* 단점 : 직접 주소 지정 방식과 비슷하게 표현할 수 있는 레지스터 크기에 제한이 있을 수 있다.

#### 레지스터 간접 주소 지정 방식
연산에 사용할 `데이터는 메모리에 저장`하고, `유효 주소를 레지스터에 저장`하고, `레지스터를 명시`하는 방법이다.
* 장점 : 간접 주소 지정 방식과 유사하지만 메모리 접근을 한 번만 하기 때문에 속도가 더 빠르다.